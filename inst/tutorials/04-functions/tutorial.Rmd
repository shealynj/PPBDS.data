---
title: "Functions"
tutorial:
  id: "04-functions"
output:
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
description: "Chapter 4 Tutorial"
---


```{r setup, include=FALSE}
library(tidyverse)
library(PPBDS.data)
library(learnr)
library(shiny)
library(gapminder)
library(skimr)
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
options(tutorial.exercise.timelimit = 60, tutorial.storage="local")
```

## Confirm Correct Package Version
###

Confirm that you have the correct version of PPBDS.data installed by pressing "Run Code."

```{r confirm, exercise=TRUE}
packageVersion('PPBDS.data')
```

The answer should be ‘0.3.2.9006’, or a higher number. If it is not, you should upgrade your installation by issuing these commands:


```{r confirm-advice, echo=TRUE, eval=FALSE}
remove.packages('PPBDS.data')  
library(remotes)  
remotes::install_github('davidkane9/PPBDS.data')  
```

Strictly speaking, it should not be necessary to remove a package. Just installing it again should overwrite the current version. But weird things sometimes happen, so removing first is the safest approach. 

## Name 
###

``` {r name}
question_text(
  "Student Name:",
  answer(NULL, correct = TRUE),
  allow_retry = TRUE,
  try_again_button = "Modify your answer",
  incorrect = "Ok"
)
```



## Introduction
###

Let's do a quick refresher about functions.


### Exercise 1

```{r if-1}
quiz(
  question("Select all that apply: Which of the following operations can be achieved by running a function in R?",
           answer("Taking a log value", correct = TRUE),
           answer("Fitting a linear model", correct = TRUE),
           answer("Averaging two numbers", correct = TRUE),
           allow_retry = TRUE)
)
```

### Exercise 2

```{r if-2}
quiz(
question("Which of the following is not a part of a function?",
         allow_retry = TRUE,
         random_answer_order = TRUE,
         answer("A name", correct = TRUE, message = "That's right, functions contain a code body, a set of formal arguments, and an environment, but not a name. They just happen to inherit a name from the object they are stored in."),
         answer("A code body", message = "Functions do require a code body! You can inspect this part of the function by using the helper function body()."),
         answer("A (potentially empty) set of formal arguments", message = "Functions do require formal arguments, even if they are empty! You can inspect this part of the function by using the helper function formals()."),
         answer("An environment", message = "Functions do require an environment, which is a self-contained space to look up the values of any objects within it. You can inspect this part of the function by using the helper function environment()."))  
)
```

### Exercise 3

```{r if-4}
quiz(
question("Which of these will run the `Sys.time` function?",
         answer("Sys.time"),
         answer("Sys.time()", correct = TRUE, 
         message = "The open and closed parentheses tell R to execute the code in the code body of the function stored in the object names Sys.time."))
)
```


## Lists and list-columns
###



A list column is a column of your data which is a list rather than a vector.



### Exercise 1

We use map_* functions to create list
```{r ll-2}
quiz(
question("What does map_dbl() mean?",
           answer("The input to the map_dbl() function must be numeric"),
           answer("The output of the map_dbl() function will be numeric", correct = TRUE),
           allow_retry = TRUE
  )
)
```

### Exercise 2

```{r ll-3}
quiz(
question("How are map_* functions different than mutate()?",
           allow_retry = TRUE,
           answer("They can take list inputs and iterate over each element of a list", correct = TRUE),
           answer("They are the same, except you can specify what output data type you'd like to have"),
           answer("They can apply functions to their inputs, whereas mutate() cannot"),
           answer("They can apply custom and anonymous functions to their inputs, whereas mutate() can only apply built-in functions to their inputs"))  
)
```

### Exercise 3

```{r ll-4}
quiz(
  question("Which of the following is correct about map_* functions?",
            allow_retry = TRUE,
           answer("You do not need the parentheses when specifying a function for the map_* function to apply. Ex: map(data, mean)", correct = TRUE),
           answer("You do need the parentheses when specifying a function for the map_* function to apply. Ex: map(data, mean())"),
           answer("You cannot have a list with NAs, or else using the map_* function will return an error", message = "This is not necessarily true. Hint: What does the \"...\" mean in map_*? Refer to the next question!")),
  question("What does the \"...\" argument mean in a map_* function?",
           allow_retry = TRUE,
           answer("Nothing. R functions commonly have an auxiliary \"...\" argument"),
           answer("It means that the map_* function will take in its default arguments"),
           answer("It means that you can specify additional arguments to be passed into the given function", correct = TRUE))
)
```


### Exercise 4

A simple tibble was created with one variable. Add to the pipe some code which creates a new list-column called `col_2` by using `str_split()` to split the phrases into "Government", "Data Science", "Preceptor", and "Primer".

```{r exercise-0, exercise=TRUE}
tibble(col_1 = c("Government and Data Science", "Preceptor and Primer"))
```

```{r exercise-0-hint, eval=FALSE}
tibble(col_1 = c("Government and Data Science", "Preceptor and Primer")) %>%
  mutate(col_2 = str_split(..., " and "))
```

### Exercise 5

Now append `str()` to the end of the pipe in order to to read the tibble contents. 

```{r exercise-1b, exercise=TRUE}
tibble(col_1 = c("Government and Data Science", "Preceptor and Primer")) %>%
  mutate(col_2 = str_split(col_1, " and "))
```

```{r exercise-1b-hint, eval=FALSE}
tibble(col_1 = c("Government and Data Science", "Preceptor and Primer")) %>%
  mutate(col_2 = str_split(..., " and ")) %>%
  str()
```


## Creating list-columns using map_*
###

### Exercise 1 

Explore the `ChickWeight` dataset using `skim()`.

```{r exercise-1, exercise=TRUE}

```

```{r exercise-1-hint, eval=FALSE}
skim(...)
```

### Exercise 2

Great! Now create a list-column of `weight`s using `mutate()`called `weight_groups`, grouping by `Diet` and `Time`.

```{r exercise-2, exercise=TRUE, eval=FALSE}
ChickWeight %>%
  group_by(Diet, Time) %>%
  mutate(...)
```

```{r exercise-2-hint, eval=FALSE}
ChickWeight %>%
  group_by(Diet, Time) %>%
  mutate(weight_groups = list(...))
```

### Exercise 3

Use the `map_dbl` function  and `mutate()` to add a new column, `mean_weight`, which is the mean weight per row. Recall that each row corresponds to a unique combination of `Diet` and `Time`. As always, you should start by copy-pasting from the last answer.

```{r exercise-3, exercise=TRUE}

```

```{r exercise-3-hint, eval=FALSE}
ChickWeight %>%
  group_by(Diet, Time) %>%
  mutate(weight_groups = list(weight)) %>%
  mutate(mean_weight = map_dbl(weight_groups, ...))
```

### Exercise 4

Now let's use `map_dbl()` to round each `mean_weight` to the nearest integer. Name this new column `rounded_mean`. 

```{r exercise-4, exercise=TRUE}

```

```{r exercise-4-hint, eval=FALSE}
ChickWeight %>%
  group_by(Diet, Time) %>%
  mutate(weight_groups = list(weight)) %>%
  mutate(mean_weight = map_dbl(weight_groups, mean)) %>%
  mutate(rounded_mean = map_dbl(mean_weight, ...))
```

Note that this answer is probably overkill. Although you can use `map_dbl()`, you don't need to. You could have just done `round(mean_weight)`.

### Exercise 5

```{r quiz-2}
quiz(caption = "",
  question("What would have happened if we had used map() instead of map_dbl() above?",
           allow_retry = TRUE,
           answer("The input would have looked for a list, rather than data of type double"),
           answer("Nothing. Map() is just the general function for all map functions"),
           answer("The output would have been a list, not a vector of type double", correct = TRUE, message = "Exactly! Try it out for yourself. This is why the world of map_* functions is so convenient. Functions such as unnest() can extract from list-columns, but there is no need to do so in this case."))
  )
```



###



### Exercise 6

Now let's use the `gapminder` dataset. Create a list-column named `gdpPercap_yearly` that lists the `gdpPercap` per year grouping by continent.

```{r exercise-7a, exercise=TRUE, eval=FALSE}

```

```{r exercise-7a-hint, eval=FALSE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(gdpPercap_yearly = list(...))
```

### Exercise 7

Now, let's build upon the previous question's code. Instead of taking the `gdpPercap`, calculate the *annual GDP of the country* in a new variable called `annual_gdp`.

```{r exercise-8a, exercise=TRUE, eval=FALSE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(...))
```

```{r exercise-8a-hint, eval=FALSE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * ...))
```

### Exercise 8

What was the lowest GDP in each `year` x `continent` category? Create a new column named `lowest` of data type "double" that contains the lowest GDP per year/continent. Pay attention to the `map_*` function you use.

```{r exercise-9a, exercise=TRUE, eval=FALSE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * pop)) %>%
  mutate(lowest = ...)
```

```{r exercise-9a-hint, eval=FALSE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * pop)) %>%
  mutate(lowest = map_dbl(annual_gdp, ...))
```

###



## Custom Functions 
###

### Exercise 1

```{r builtinfunctions}
quiz(caption = "",
  question("What is the first step of writing a function?",
         answer("Choose a name, then type <- function(){", message = "You shouldn't type function() until you have code that works with a real test case."),
         answer("Create a real R object (or set of objects)", correct = TRUE, message = "You can then use the object to test your code."),
         answer("Assign argument names to your function"),
         answer("Write a help page that describes how your function will work."),
         allow_retry = TRUE))
```

### Exercise 2

Here is a custom function we will call `foo`:

```{r foo-1, echo = FALSE}
foo <- function(){
  a <- 10
  a
}
```

```{r foo-2, echo=TRUE}
body(foo)
```

What will be the final value of `a` if I run the following three lines of code in order?

```{r foo-3, eval=FALSE, echo=TRUE}
a <- 1
foo()
a
```

```{r quiz-1b, echo = FALSE}
quiz(
  question("",
         answer("1", correct = TRUE, message = "What happens in a function, stays in the function. foo() will not change the value of a outside of foo()."),
         answer("10"),
         answer("Running a will return an error."),
         allow_retry = TRUE)
  )
```

### Exercise 3

Put yourself in the shoes of a teacher: You've given your students 10 homework assignments and announced that you will drop their lowest homework score. Their final grade will be the average score of the remaining homeworks.

To make your life easier, you want to write an R function that will take a vector of 10 homework scores and return a final grade. 

Create an object named `x` that contains the vector `c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)`.
*`x` will be the grades of your test student. 

```{r obj, exercise=TRUE}

```

### Exercise 4

Use `sum()`, `min()`, `/`, `9` and parentheses to calculate the final grade for student `x`.

```{r norm, exercise=TRUE}
x <- c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)
```

```{r norm-hint, eval=FALSE}
(sum(x) - min(x)) / ...
```

### Exercise 5

Save the code below as a function named `grade`.
```{r grade-setup}
x <- c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)
```

```{r grade, exercise=TRUE}
(sum(x) - min(x)) / 9
```

```{r grade-hint, eval=FALSE}
grade <- function(){ 
  ...
}
```

### Exercise 6

Each time you call `grade()` it computes the final grade of the vector `x` that contains `c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)`. We'd like to use `grade()` with new vectors that have new values.

Make `x` a formal argument.

```{r exercise-random-name, exercise=TRUE, eval=FALSE}
grade <- function(){ 
  ...
}
```

```{r exercise-random-name-hint, eval=FALSE}
grade <- function(...){ 
  (sum(x) - min(x)) / 9
}
```

### Exercise 7

Calculate the final grade of the vector `c(100, 90, 90, 90, 90, 90, 90, 90, 90, 80)`. 

```{r make-grade-setup}
grade <- function(x){ 
  (sum(x) - min(x)) / 9
}
```

```{r make-grade, exercise=TRUE}

```

```{r make-grade-hint, eval=FALSE}
Use the provided vector!
```

### Exercise 8

```{r recap}
quiz(
  question("What is the final grade you calculated above?",
              answer("91.11", correct = TRUE),
              answer("90.00"),
              answer("92.33"),
              answer("89.91"),
              random_answer_order = TRUE,
              allow_retry = TRUE)
  )
```


### Exercise 9

Let's write a function that grades by counting a student's highest score twice and then taking an average of the 11 scores.

```{r quiz-2c, echo = FALSE}
question("Do you have a test vector that you can use?",
         answer("Test vector? We don't need no stinking test vector.", 
                message = "Yes you do."),
         answer("Yes, we can reuse the vector named x.", correct=TRUE),
         allow_retry = TRUE,
         random_answer_order = TRUE)
```

### Exercise 11

Write a piece of code that uses `max()` to double count the highest score in `x` and then takes the average of the 11 results.

```{r e3, exercise=TRUE}
x <- c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)
```

```{r e3-hint, eval=FALSE}
(sum(x) + max(x)) / ...
```

### Exercise 12

Wrap your code in `function()` and save it to the name `grade2`. Then define the argument(s) for the function.

```{r e4, exercise=TRUE}
(sum(x) + max(x)) / 11
```

```{r e4-hint, eval=FALSE}
grade2 <- function(x){
  ...
}
```

### Exercise 13

```{r gradingquiz}
quiz(caption = "",
     question("What does grade2(x) return?",
     answer("99.09", correct = TRUE),
     answer("91.11"),
     answer("95.45"),
     answer("96.91"),
     allow_retry = TRUE,
     random_answer_order = TRUE))
```

## Using `runif()` and `rnorm()`
###

Remember `runif()` and `rnorm()` from Chapter 2? These two functions generate a random uniform and normal distribution, respectively. 


### Exercise 1

Write a custom function named `add_rvs()` that adds together 1 random variable generated by `runif()` and 1 random variable generated by `rnorm()`. Use `n=1` and the default values for the other arguments.

```{r rvs_q, exercise=TRUE}

```

```{r rvs_q-hint-1, eval=FALSE}
You can add random variables like so: runif(1) + rnorm(1)
```

```{r rvs_q-hint-2, eval=FALSE}
add_rvs <- function(){
  runif(1) + rnorm(...)
}
```

### Exercise 2

What if you wanted to customize `n`? Add a formal argument `n` to your `add_rvs()` function with a default value of 1.

```{r rvs_q2, exercise=TRUE}

```

```{r rvs_q2-hint, eval=FALSE}
add_rvs <- function(n = 1){
  runif(n) + rnorm(...)
}
```




## Testing
###

Let's learn about testing.


### Exercise 1
We use the `return()` function whenever we want to return a value that is not the last line of the code body.

```{r is-1, echo=TRUE, eval=FALSE}
impatient_square <- function(x){
  return(x)
  x^2
}
```


```{r return-quiz, echo = FALSE}
quiz(caption = "",
  question("When should you use return()?",
           answer("Whenever you want your function to return a value from the last line of the code body", message = "Remember, R functions automatically return the last value."),
           answer("Whenever you want to return a value that is not the last line of the code body", correct = TRUE, message = "Correct! This can either be for diagnosis purposes when debugging or for unusual control flow cases in general"),
           allow_retry = TRUE))
```

### Exercise 2

```{r is-2, eval=FALSE, echo=TRUE}
immovable_square <- function(x){
  stop("I refuse to proceed.")
  x^2
}
```

```{r stop-quiz}
quiz(caption = "",
  question("What does `immovable_square(2)` return?",
         answer("4", message = 'R will stop executing `immovable_square()` and throw an error when it comes to `stop("I refuse to proceed.")`.'),
         answer("Error in immovable_square(2) : I refuse to proceed.", correct = TRUE, message = 'R will stop executing `immovable_square()` and throw an error when it comes to `stop("I refuse to proceed")`. The error message will look just like this answer; R inserts the message that you pass as a character string to `stop()`.'),
         allow_retry = TRUE))
```

### Exercise 3

This function is called `angry()`. Add a line of code that throws the message "Wrong! I am angry!" using `stop()`.

```{r angry, exercise=TRUE}
angry <- function(x){
  x
}
```

```{r angry-hint, eval=FALSE}
angry <- function(x){
  ...("Wrong! I am angry!")
  x
}
```

### Exercise 4

Nice, now we have an appropriately angry function that always yells at us. This isn't particularly useful. Make it so that `angry()` only yells at us if the x input is not a character. Also change the error message to something more useful: "x must be a character." This method is also known as the "if then stop".

```{r ifthenstop, exercise=TRUE}
angry <- function(x){
  x
}
```

```{r ifthenstop-hint, eval=FALSE}
angry <- function(x){
  if(!is.character(x)){
    ...("x must be a character.")
  }
  x
}
```

### Exercise 5

What if we wanted to incorporate `testthat`? Use the `showfailure()` function to see what happens when we plug in `x = 1` to `angry()`.

```{r showfailure-setup}
library(testthat)
angry <- function(x){
  if(!is.character(x)){
    stop("x must be a character.")
  }
  x
}
```

```{r showfailure, exercise=TRUE, eval=FALSE}
show_failure(...)
```

```{r showfailure-hint, eval=FALSE}
show_failure(angry(x=...))
```

### Exercise 6

Run the following function, which we've pre-defined behind the scenes.

```{r mysteryfunc-setup}
library(testthat)
mystery <- function(x = 15){
  if(!is.numeric(x)){
    stop("x must be a number.")
  }
  if(x <= 10){
    stop("x must be greater than 10.")
  }
  if(x == 13){
    stop("13 is an unlucky number. Choose a different number.")
  }
  sqrt(x)
}
```

```{r mysteryfunc, exercise=TRUE, eval=FALSE}
mystery()
```

```{r mysteryfunction}
quiz(
  question("Select all that apply. Which of the following happens when you run mystery()?",
           answer("When you run mystery(13), you get an error that says: \"13 is an unlucky number. Choose a different number.\"", correct = TRUE),
           answer("When you run mystery(), you get no error.", correct = TRUE),
           answer("When you run mystery(10), you get no error"),
           answer("When you run mystery(\"a\"), you get an error that says: \"x must be a number.\"", correct = TRUE),
           allow_retry = TRUE))
```

### Exercise 7

```{r mysteryfunc2-setup}
library(testthat)
mystery <- function(x = 15){
  if(!is.numeric(x)){
    stop("x must be a number.")
  }
  if(x <= 10){
    stop("x must be greater than 10.")
  }
  if(x == 13){
    stop("13 is an unlucky number. Choose a different number.")
  }
  sqrt(x)
}
```

```{r mysteryfunc2, exercise=TRUE, eval=FALSE}
test_that('invalid args are detected', {
  expect_error(mystery(-1))
  expect_error(mystery(15))
})
```

```{r mysteryfunction2}
quiz(
  question("When you run the following formal unit test, what do you get?",
           answer("Nothing. This means the test worked as expected and no news is good news."),
           answer("Error: Test failed: 'invalid args are detected' * `mystery(15)` did not throw an error.", correct = TRUE),
           answer("Nothing. However, no result is a bad result and we have to peek under the hood further."),
           answer("Error: Test failed: 'invalid args are detected' * `mystery(-1)` did not throw an error."),
           allow_retry = TRUE,
           random_answer_order = TRUE))
```

## Handling NAs
###

### Exercise 1

```{r if-quiz, echo = FALSE}
question("Which describes `if`'s behavior? (Check all that apply).",
         answer("`if` takes a logical test and a piece of code. It runs the code _if_ the test returns TRUE.", correct = TRUE, message = "`if` is a way to run code only in certain cases. When you use `if`, you first pass it a logical test surrounded by parentheses and then a piece of code."),
         answer("`if` takes a logical test and a piece of code. It does not run the code _if_ the logical test returns FALSE.", correct = TRUE, message = "`if` will run the piece of code if the logical test returns TRUE and not run the code if the logical test returns FALSE."),
         answer("`if` returns the results of the code that appears in _parentheses_ behind `if`."),
         answer("`if` always executes all of the code that follows it.", message = "`if` will always execute the logical test that appears in parentheses behind `if`. However, `if` will only execute the code that appears after the logical test if the logical test returns TRUE."),
         allow_retry = TRUE)
```

### Exercise 2

Many data sets use their own symbols to represent missing values. For example, NOAA will often use -99 to represent missing values in weather data sets. Let's write a function that checks whether a value is -99, and if so replaces the value with NA, like this:

```{r clean-1, echo = FALSE}
clean <- function(x){
  if(x == -99) x <- NA
  x
}
```

```{r clean-2, echo=TRUE}
clean(1)
clean(-99)
```

### Exercise 3

Add an `if` statement to the beginning of `clean()`. Your statement should assign NA to x if x equals -99.

```{r clean-setup}
x <- -99
```

```{r clean, exercise=TRUE}
clean <- function(x){
  # add if statement here
  x
}
```

```{r clean-solution}
clean <- function(x){
  if(x == -99) x <- NA
  x
}
```

## Using `stopifnot()`
###

### Exercise 1


```{r stopifnot-quiz, echo = FALSE}
quiz(
  question('Which of these does the equivalent of `if(x < 0) stop("x is less than zero")`?',
         answer('`stopifnot(x < 0)`', message = "Good guess! But the function isn't called `stopif()`; it's called `stopifnot()`."),
         answer('`stopifnot(x >= 0)`', correct = TRUE, message = "`stopifnot()` stops if a condition is _not_ met, which is slightly different than `if` + `stop()`."),
         allow_retry = TRUE),
  question("How is stopifnot() different from if` + stop()?",
           allow_retry = TRUE,
           random_answer_order = TRUE,
           answer("Instead of checking whether a condition is met, `stopifnot()` checks whether a condition is not met", correct = TRUE),
           answer("stopifnot() always passes along a custom error message"),
           answer("stopifnot() cannot take logical arguments")))
```

### Exercise 2

Replace the `if` + `stop()` statement in `clean()` with `stopifnot()`. 

```{r stopifnot, exercise=TRUE}
clean <- function(x){
  if(is.null(x)) stop("x is NULL")
  if(x == -99) return(NA)
  if(x == ".") return(NA)
  if(x == "NaN") return(NA)
  x
}
```

```{r stopifnot-solution}
clean <- function(x){
  stopifnot(!is.null(x))
  if(x == -99) return(NA)
  if(x == ".") return(NA)
  if(x == "NaN") return(NA)
  x
}
```

### Exercise 3

Rewrite the below function using `case_when()`.

```{r foo-6, echo=TRUE}
foo <- function(x){
  if(x > 2) "a"
  else if(x < 2) "b"
  else if(x == 1) "c"
  else "d"
}
```

```{r foo_rewrite, exercise=TRUE}
foo2 <- function(x){
  case_when(
    
    # Insert code here!
    
  )
}
```

```{r foo_rewrite-hint-1, eval=FALSE}
foo2 <- function(x){
  case_when(
    x > 2  ~ "a",
    x < 2  ~ "b",
    ...
  )
}
```

```{r foo_rewrite-hint-2, eval=FALSE}
foo2 <- function(x){
  case_when(
    x > 2  ~ "a",
    x < 2  ~ "b",
    x == 1 ~ "c",
    TRUE ~ ...
  )
}
```

### Exercise 4

Rewrite the multi-part version of `clean()` to use `case_when()`, which will allow `clean()` to handle vectors. Retain each case. Assume where necessary that `clean()` will only work with real numbers.

```{r when, exercise=TRUE}
clean <- function(x){
  if(x == -99) NA 
  else if(x == ".") NA
  else if(x == "") NA
  else if(x == "NaN") NA
  else x
}
```

```{r when-hint, eval=FALSE}
clean <- function(x){
  case_when(
    x == -99 ~ NA_real_, 
    x == "." ~ NA_real_,
    x == "" ~ NA_real_,
    x == "NaN" ~ NA_real_,
    TRUE ~ ...
  )
}
```



## Monthly temperatures exercise
###

### Exercise 1

Explore the `airquality` dataset using `skim()`.

```{r exercise-1a, exercise=TRUE}

```

```{r exercise-1a-hint, eval=FALSE}
skim(...)
```

### Exercise 2

Create a list-column of monthly temperatures called `monthly_temp`, grouping by `Month`.

```{r exercise-2a, exercise=TRUE}

```

```{r exercise-2a-hint, eval=FALSE}
airquality %>%
   group_by(Month) %>%
   mutate(monthly_temp = list(...))
```

### Exercise 3

```{r quiz-4}
quiz(caption = "",
  question("Which of the following possibilities for filling in the blank is syntactically correct and converts from Fahrenheit to Celsius?",
           answer("(. - 32) * 5/9)"),
           answer("(- 32 * 5/9)"),
           answer("~ (. - 32) * 5/9)", correct = TRUE),
           answer("~ (fahrenheit - 32) * 5/9)"))
)
```

### Exercise 4

Use a `map_*` function to convert all of the temperatures in `monthly_temp` from Fahrenheit to Celsius, creating a new variable `temp_celsius`. Hint: Use the formula from the quiz above!

```{r exercise-3a, exercise=TRUE, eval=FALSE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(...)
```

```{r exercise-3a-hint, eval=FALSE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ...))
```

### Exercise 5

Oops! The scientists made a mistake in which all of the temperatures were mis-recorded. For temperatures recorded at or below 20 degrees Celsius, the true temperature is actually 1 degree Celsius lower. For temperatures recorded as higher than 20 degrees Celsius, the true temperature is actually 3 degrees Celsius higher.

Write an anonymous function that rectifies the scientists' mistake by using `case_when()`.

```{r exercise-4a, exercise=TRUE, eval=FALSE}
function(x) 
  case_when(...)
```

```{r exercise-4a-solution}
function(x) 
  case_when(x <= 20 ~ x - 1,
            x > 20 ~ x + 3)
```

### Exercise 6

Now use this function along with `map()`, swapping out the function code after the `~` in the `map()` argument.

```{r exercise-5a, exercise=TRUE, eval=FALSE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9)) %>%
  mutate(temp_celsius = map(temp_celsius, ~ ...))
```

```{r exercise-5a-hint, eval=FALSE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9)) %>%
  mutate(temp_celsius = map(temp_celsius, ~ case_when(...)))
```

### Exercise 7

Now let's get a sense of the "corrected" data. Sort the temperatures from coldest to hottest each month.

```{r exercise-6a, exercise=TRUE, eval=FALSE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9)) %>%
  mutate(temp_celsius = map(temp_celsius, ~ case_when(. <= 20 ~ . - 1,
            . > 20 ~ . + 3)))
```

```{r exercise-6a-solution}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9)) %>%
  mutate(temp_celsius = map(temp_celsius, ~ sort(case_when(. <= 20 ~ . - 1,
            . > 20 ~ . + 3))))
```


## Coin Flipping exercise
###

Let's create a function, `coin_flip()`, that takes an input `n` of the number of times to flip a coin and adds up the number of Tails.

### Exercise 1

Let's start by creating a minimally viable function called `starter_coin()` that flips one coin once and prints out `H` or `T`. Remember: You can paste vectors as an argument into `sample()`!

```{r coin1, exercise=TRUE, eval=FALSE}

```

```{r coin1-hint, eval=FALSE}
starter_coin <- function() sample(c("H", "T"), ...)
```

### Exercise 2

Now let's take it up a notch and add in a formal argument `n` that specifies the number of times to flip the coin.

```{r coin2, exercise=TRUE, eval=FALSE}

```

```{r coin2-hint, eval=FALSE}
starter_coin <- function(n) sample(c("H", "T"), n, replace = ...)
```

### Exercise 3

Add in a sensible `stopifnot()` to your function that checks whether the input `n` is numeric.

```{r coin3, exercise=TRUE}

```

```{r coin3-hint, eval=FALSE}
starter_coin <- function(n){
  stopifnot(is.numeric(...))
  sample(c("H", "T"), n, replace = TRUE)
}
```

### Exercise 4

Great! Now we should be able to create `coin_flip()`, which counts the number of Tails for `n` flips. Set the default value of `n` to 1.

```{r coin4, exercise=TRUE, eval=FALSE}
coin_flip <- function(n = 1){
  ...
}
```

```{r coin4-hint-1, eval=FALSE}
Use the code from starter_coin() and sum().
```

```{r coin4-hint-2, eval=FALSE}
coin_flip <- function(n = 1){
  stopifnot(is.numeric(n))
  sum(sample(c("H", "T"), n, replace = TRUE) == ...)
}
```

### Exercise 5

Now let's create a function called `five_flips` that counts how many Tails occur in five coin flips, or the equivalent of `coin_flip(5)`, but calls it `n` times.
* Set the default value of `n` separate flips to 1.
* Use a `map_*` function to apply the `rep()` function to `coin_flip()` `n` times.

```{r coin5, exercise=TRUE}
five_flips <- function(n = 1){
}
```

```{r coin5-hint-1, eval=FALSE}
The map function you are looking for is map_int().
```

```{r coin5-hint-2, eval=FALSE}
rep(x,n) means that you are flipping x coins n times.
```

```{r coin5-hint-3, eval=FALSE}
five_flips <- function(n = 1){
  stopifnot(is.numeric(n))
  map_int(rep(5, n), ...)
}
```

### Exercise 6


```{r coin-quiz}
quiz(
  question("Select all that apply: Which of the following is equivalent to flipping 5 coins 10 times?",
           answer("five_flips(10)", correct = TRUE, message = "Use this function for the next exercise!"),
           answer("five_flips(5, 10)"),
           answer("five_flips(5)"),
           allow_retry = TRUE,
           random_answer_order = TRUE))
```

### Exercise 7

Create a tibble named `x` with one variable: `flips`. `flips` is a list column of 10 observations, each element of which is result of flipping 5 coins 10 times.  Make sure to use the correct `map_*` function.

```{r coin7, exercise=TRUE, eval=FALSE}
x <- tibble(flips = ...)
```

```{r coin7-hint, eval=FALSE}
x <- tibble(flips = map(rep(10, 10), ...))
```

### Exercise 8

What if I wanted to return a single new list-column named `descriptive_stats` that contained a list of the mean, minimum, and maximum values? Time to write a function!

```{r coin9-setup}
coin_flip <- function(n = 1){
  stopifnot(is.numeric(n))
  sum(sample(c("H", "T"), n, replace = TRUE) == "T")
}
five_flips <- function(n = 1){
  stopifnot(is.numeric(n))
  map_int(rep(5, n), coin_flip)
}
x <- tibble(flips = map(rep(10, 10), five_flips))
stat_ops <- function(x){
  a <- mean(x)
  b <- min(x)
  c <- max(x)
  return(c(a,b,c))
}
```

```{r coin9, exercise=TRUE, eval=FALSE}
x %>%
   mutate(descriptive_stats = ...)
```

```{r coin9-hint, eval=FALSE}
x %>%
   mutate(descriptive_stats = map(flips, ...))
```



## Random variables
###

### Exercise 1

Let's create a function `biggest()`, which takes the larger of two random variables. Use `n = 1` for both random variables.

```{r biggest1, exercise=TRUE, eval=FALSE}
biggest <- function(){
  ...
}

```

```{r biggest1-hint, eval=FALSE}
biggest <- function(){
  max(runif(...), rnorm(...))
}

```

### Exercise 2

Modify `biggest()` so that it prints out "Uniform" if the larger variable is the uniformally distributed random variable, and "Normal" if otherwise.
* Use `case_when()` with `TRUE ~ "Tie"`.
* Remember that `runif()` and `rnorm()` generate *random* values every time they are called...

```{r biggest2, exercise=TRUE, eval=FALSE}
biggest <- function(){
  ...
}

```

```{r biggest2-hint-1, eval=FALSE}
biggest <- function(){
  x <- runif(1)
  y <- rnorm(1)
  case_when(...)
}
```

```{r biggest2-hint-2, eval=FALSE}
biggest <- function(){
  x <- runif(1)
  y <- rnorm(1)
  case_when(x > y ~ "Uniform",
           y > x ~ "Normal",
           ...)
}
```

### Exercise 3

We'd like for `biggest()` to return a vector of two elements: The name of the distribution of the larger random variable and its value. If the two values are identical, we'd like for the function to return "Tie" and the value of one of the variables (since they are identical).

```{r biggest3, exercise=TRUE, eval=FALSE}
biggest <- function(){
  x <- runif(1)
  y <- rnorm(1)
  case_when(x > y ~ ...,
            y > x ~ ...,
            TRUE ~ ...)
}
```

```{r biggest3-hint, eval=FALSE}
biggest <- function(){
  x <- runif(1)
  y <- rnorm(1)
  case_when(x > y ~ c("Uniform", x),
           y > x ~ c("Normal", y),
           TRUE ~ c("Tie", ...))
}
```

### Exercise 4

Let's create a new function named `repeat_biggest()` that does so by calling `biggest()` `n` number of times.
* Use `replicate()` to call the function multiple times.

```{r newfunc, exercise=TRUE, eval=FALSE}
repeat_biggest <- function(n){
  replicate(...)
}
```

```{r newfunc-solution}
repeat_biggest <- function(n = 1){
  replicate(n, biggest())
}
```

### Exercise 5

Create a tibble named `rvs` with one variable: `trials`. `trials` is a list column of 25 observations, each element of which is a result of calling `repeat_biggest(3)`.

```{r lastq, exercise=TRUE, eval=FALSE}
rvs <- tibble(...)
```

```{r lastq-hint, eval=FALSE}
rvs <- tibble(trials = map(rep(3, 25), ...))
```

## The Crooked Casino
###

<!-- DK: Show the plot at the start. Discuss its meaning. Hint at what we will discuss in chapter 5. Then, walk through the step-by-step creation of it. -->

Recall the function we wrote in the chapter to model a crooked game of craps. `crooked_craps()` is expected to return a winning 7 or 11 only *half* of the time the sum is actually 7 or 11. It returns a 2 much more often than it should. Code:

```{r crooks, echo=TRUE}
crooked_dice <- function(n = 1){
  stopifnot(is.numeric(n))
  stopifnot(n >= 0)
  roll <- sum(sample(1:6, n, replace = TRUE))
  ifelse((roll == 7 | roll == 11) && runif(1) >= 0.5, 2, roll)
}

crooked_craps <- function(n = 1){
  stopifnot(is.numeric(n))
  map_dbl(rep(2, n), crooked_dice)
}
```

Let's put our visualization skills to the test.

### Exercise 1

Create a tibble with column "games" and run `crooked_craps()` 100 times.


```{r crooked-1, exercise=TRUE}

```

```{r crooked-1-hint, eval=FALSE}
tibble(games = crooked_craps(...))
```

### Exercise 2

Create a barplot with `games` on the `x` axis.


```{r crooked-2, exercise=TRUE, eval=FALSE}
tibble(games = crooked_craps(100))
```

### Exercise 3

Now, change the `x` axis scale to increment by integers from 2 to 12.

```{r crooked-3, exercise=TRUE, eval=FALSE}
tibble(games = crooked_craps(100)) %>%
  ggplot(aes(x = games)) +
  geom_bar()
```

```{r crooked-3-hint, eval=FALSE}
tibble(games = crooked_craps(100)) %>%
  ggplot(aes(x = games)) +
  geom_bar() %>%
  scale_x_continuous(breaks = seq(...))
```

### Exercise 4

Use an appropriate `map_*` function and `rep()` to call `crooked_craps(100)` 10 times. Create a tibble named `x` with a column named `games`.

```{r crooked-4, exercise=TRUE, eval=FALSE}

```

```{r crooked-4-hint, eval=FALSE}
x <- tibble(games = map(rep(100, 10), ...))
```

### Exercise 5

Inside each of these iterations of 100 rolls, we want to count the number of 3's and 11's. Technically, with a fair die one would expect as many 11's to appear as 3's. 11's can be obtained in two different ways: by adding 5 + 6 and 6 + 5. The same goes for 3's: by adding 1 + 2 and 2 + 1.

First, count the number of 3's. You can do so by using a the appropriate `map_*` function and an anonymous function defined as `sum(. == 3)`.


```{r crooked-5, exercise=TRUE, eval=FALSE}
x <- tibble(games = map(rep(100, 10), crooked_craps)) %>%
  mutate(counts = ...)
```

```{r crooked-5-hint, eval=FALSE}
x <- tibble(games = map(rep(100, 10), crooked_craps)) %>%
  mutate(counts = map_int(games, ~(...)))
```

### Exercise 6

Now, modify `counts` so that it is a list-column of 2 elements per list: The number of 3's, then the number of 11's.


```{r crooked-6, exercise = TRUE}
x <- tibble(games = map(rep(100, 10), crooked_craps)) %>%
  mutate(counts = map_int(games, ~sum(. == 3)))
```

```{r crooked-6-hint}
x <- tibble(games = map(rep(100, 10), crooked_craps)) %>%
  mutate(counts = map(games, ~list(sum(. == 3), ...)))
```

### Exercise 7

View the tibble with `str()`.


```{r crooked-7, exercise = TRUE}
x <- tibble(games = map(rep(100, 10), crooked_craps)) %>%
  mutate(counts = map(games, ~list(sum(. == 3), sum(. == 11))))
```

### Exercise 8

```{r finalquiz}
quiz(question("Based off of your observations and prior knowledge, is our crooked_craps() function truly crooked (compared to what we'd expect from a game of craps with two fair dice)?",
     allow_retry = TRUE,
     random_answer_order = TRUE,
     answer("Yes, because the number of 3's rolled seems to generally be higher than the number of 11's rolled.", correct = TRUE, message = "Exactly! This might've been a different story if we didn't know the contents of the crooked_craps() function, since the difference between the number of 3's and the number of 11's rolled could be chalked up to natural variation. However, we wrote the function to be crooked. Additionally, as we increase the number of simulations, the more confident we can be that the data reflects a real difference in the frequency of 3's and 11's rolled."),
     answer("Yes, because there will always be more 3's than 11's rolled in 100 rolls", message = "While that could have been the case for your 10 different trials, imagine if you ran 1000 or 1 million trials. Could you say with absolute confidence that not a single trial would yield more 11's than 3's?")))
```

## Submit

Some of these exercises were taken from the collection of [RStudio Primers](https://rstudio.cloud/learn/primers), a great resource for practicing your skills.
```{r context="setup"}
submission_ui
```

```{r context="server"}
submission_server()
```
